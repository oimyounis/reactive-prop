class ReactiveProp {
    static _DEFINED = {};
    static update() {
        for (const key in this._DEFINED) {
            const prop: ReactiveProp = this._DEFINED[key];

            prop.update();
        }
    }

    private _element = null;
    private _definitionName = '';
    private _prop = '';
    private _reactiveName = '';
    private _value = '';
    private _bound = [];

    constructor(element, definitionName: string, prop: string, reactiveName: string, initValue = '') {
        this._element = element;
        this._definitionName = definitionName;
        this._prop = prop;
        this._reactiveName = reactiveName;

        this.setValue(initValue);

        if (ReactiveProp._DEFINED[reactiveName] === undefined) {
            ReactiveProp._DEFINED[reactiveName] = this;
        }
        else {
            this._bound.push(ReactiveProp._DEFINED[reactiveName]._element);
        }
    }

    getValue() {
        let _value = this._element.attrib(this._prop);
        if (_value === null) {
            _value = '';
        }
        this._value = _value;
        return this._value;
    }

    setValue(value) {
        this._value = value;

        if (this._element._element.getAttribute(this._prop) === null) {
            if (this._element._element[this._prop] !== undefined) {
                this._element._element[this._prop] = value;
            }
        }
        else {
            this._element._element.setAttribute(this._prop, value);
        }
    }

    bind(element) {
        this._bound.push(element);
    }

    update() {
        for (const element of this._bound) {
            element.setAttrib(this);
        }
        this._element.setAttrib(this);
    }
}

class ReactiveElement {
    private _element = null;
    private _propList = {};

    constructor(selector: string) {
        const el = document.querySelector(selector);

        if (el === null) {
            throw `Element with selector "${selector}" does not exist`;
        }

        this._element = el;

        el.addEventListener('change', () => {
            for (const key in this._propList) {
                const prop = this._propList[key];

                prop.update();
            }
        });
        el.addEventListener('input', () => {
            for (const key in this._propList) {
                const prop = this._propList[key];

                prop.update();
            }
        });

        this._mapProps();
    }

    private _mapProps() {
        const propMapCopy = { ...this._element.attributes };
        propMapCopy.length = Object.keys(propMapCopy).length;

        for (const prop of propMapCopy) {
            const name = prop.name;
            const reactiveName = prop.value;

            if (name.indexOf('r-') == 0) {
                const propName = name.substr(2);
                let initValue = this._element.getAttribute(propName);
                if (initValue === null) {
                    initValue = '';
                }

                let propObj = new ReactiveProp(this, name, propName, reactiveName, initValue);
                this._propList[reactiveName] = propObj;

                this._defineReactiveProp(reactiveName);
                this._bindElement(reactiveName);

                this._element.attributes.removeNamedItem(name);
            }
        }
    }

    private _defineReactiveProp(reactiveName) {
        Object.defineProperty(this, reactiveName, {
            get: () => {
                const _rprop: ReactiveProp = ReactiveProp._DEFINED[reactiveName];

                if (_rprop === null) {
                    throw 'Tried to access a none existing reactive property';
                }

                return _rprop.getValue();
            },
            set: (value) => {
                const _rprop: ReactiveProp = ReactiveProp._DEFINED[reactiveName];

                if (_rprop === null) {
                    throw 'Tried to access a none existing reactive property';
                }

                _rprop.setValue(value);
                _rprop.update();
            },
            enumerable: true,
            configurable: true
        });
    }

    private _bindElement(reactiveName) {
        let defined: ReactiveProp = ReactiveProp._DEFINED[reactiveName];

        if (defined !== undefined) {
            defined.bind(this);
        }
    }

    attrib(name) {
        let _v = this._element.getAttribute(name);

        if (_v === null) {
           if (this._element[name] !== undefined) {
               _v = this._element[name];
           }
        }

        return _v;
    }

    setAttrib(prop) {
        const value = prop.getValue();

        const propToSet = this._propList[prop._reactiveName];

        propToSet.setValue(value);
    }
}